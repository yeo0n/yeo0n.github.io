---
layout: single
title: "[Dreamhack] x86-64 assembly Quiz"
date: 2024-04-03 18:21 +0900
categories: 
    - SYSTEM-write-up
tag:
typora-root-url: ../
toc: true
toc_sticky: true
toc_label: 목차
author_profile: true
comment: true
sidebar:
    nav: "docs"
---



## **Q12. end로 점프하면 프로그램이 종료된다고 가정하자. 프로그램이 종료됐을 때, 0x400000 부터 0x400019까지의 데이터를 대응되는 아스키 문자로 변환하면?**

<img src="/images/2024-04-03-x86-assembly-quiz/image-20240403182319453.png" alt="image-20240403182319453" style="zoom: 50%;" />

<br>

### 풀이

이 문제는 약간의 규칙이 존재한다. 

<br>
1번의 코드를 실행하면, [rsi+rcx]는 0x400000이 되고 이 주소는 0x67이라는 데이터를 가리킨다. 이를 dl이라는 값에 저장하게 된다. 

<br>

2번 코드를 실행하면 위의 dl 값과 0x30과 xor 연산을 수행하라고 나온다. 이 과정에서 약간의 규칙이 있는데 16진수 30을 2진수로 변환하면 0011 0000이 나온다. 여기서 **뒤에 있는** **0000은 어떤 값과 연산해도 dl 값인 16진수 값에서 1의 자리 수가 그대로 내려져 온다는 것**이다. 따라서 수행해보면 0011과 10의 자리 숫자에 있는 6과 xor연산을 하게 되면 0011 0110 이므로 0101이 되고, 1의 자리 숫자는 dl에서 그대로 내려져 오므로 0x57이다.

<br>

3번 코드를 실행하면 이 0x57이 Byte PTR[rsi+rcx]에 저장되므로 0x67자리에 0x57로 바뀐다고 보면 된다.

<br>
4번 코드를 보면 rcx가 inc 명령으로 인해 1 증가하게 된다.

<br>

5번 코드는 cmp로 이 1과 0x19를 비교하고 있다. 6번 코드에서는 jg로 인해서 앞에 있는 값이 더 커야 다음으로 넘어갈 수 있다. 따라서 **0x19보다 rcx 값이 커야하므로, rcx가 0x20이 되어야 한다.** 0x20을 10진수로 변환하면 26이되고 그럼 이번 문제에서 문자열의 자릿수는 26이라는 것을 알 수 있다.

<br>

위 과정을 반복하다보면, 4x 데이터는 0x30과 xor 연산을 수행해 10자리수가 7이 되고, 5x 데이터는 6이 된다. 또한 0x10과 xor연산을 수행하면 공백으로, 위 과정을 반복하면 **Welcome to assembly world!** 라는 문자열을 나타낸다는 것을 알 수 있다.

![image-20240403183812196](/images/2024-04-03-x86-assembly-quiz/image-20240403183812196.png)
